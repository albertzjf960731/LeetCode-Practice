# 树

## 二叉树

### 层次遍历

使用 BFS 进行层次遍历。不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。

## Binary Indexed Tree

Binary Indexed Trees（中文名为树状数组，下文简称为BIT）是一种特殊的数据结构，可多用于高效计算数列的前缀和，区间和。对于长度为n的数组，它可以以O(logn)的时间得到任意前缀和 $\sum_{i=1}^j a[i], 1<=j<=N$，并同时支持在 O(logn)时间内支持动态单点值的修改。空间复杂度 O(n)

虽然BIT名称中带有tree这个词，但是实际存储时是利用两个数组进行存储，记这两个数组为nums和 BIT。假设我们现在需要对原始数组 arr 进行前缀求和和区间求和，那么可以按照以下步骤进行。

### 1. 初始化

nums[i] = arr[i]
BIT[i]=$\sum_{k=i−lowestbit(i)+1}^i$arr[k]

上面的lowestbit(i)指将i转为二进制后,最后一个1的位置所代表的数值。如lowestbit(1)=1、lowestbit(6)=2，具体的实现可通过(i&-i)获取。

下图就是初始化后的情况，横轴为数组的下标(记为i)，纵轴为下标数值对应的lowestbit（i&-i），长方形表示BIT[i]涵盖的求和的范围

![binary_index_tree](./../img/fenwick_tree_binary_index_tree.jpg)

可以看到每个数组下标的lowestbit（也就是图中描黑的部分）在形态上构成了一棵树的形状，这也是名称中tree的来源。并且对于每个下标的lowestbit表示成的tree node有以下特性。

(1)假如i是左子节点，那么其父节点下标为i+(lowestbit(i))
(2)假如i是右子节点，那么其父节点下标为i-(lowestbit(i))

上面这两个特性非常重要，也是我们进行后文分析的重要基础。

### 2. 更新一个数值

假如要修改原始数组 arr 中的下标为i的值，那么需要修改nums数组中对应下标的值。除此之外还需要修改BIT数组中涵盖了arr[i]的值。结合上图可以知道，BIT数组中涵盖了arr[i]的值为下标i及其所有父节点，伪代码如下

```python
while i < n:
    BIT[i] += new_value
    i += (i&-i)
```

### 3. 区间求和

假如要求arr数组下标区间为[i,j]的数值之和，那么可以先求下标为[0,i-1]的数值之和，再求下标为[0,j]的数值之和，然后用后者减去前者即可。

通过观察上面初始化后的图可以知道求[0, i]可以通过下面的方法：

```python
count = 0
while i>0:
    count += BIT[i]
    i -= (i&-i)
```

通过上面的操作，通过利用额外的两个数数组，将原来的区间求和的操作从时间复杂度O(n)变为了O(logn),但是更新数组的值的操作的时间复杂度也从原来的O(1)变为了O(logn),所以这种数据结构更适合用于区间求和频繁的应用场景。


